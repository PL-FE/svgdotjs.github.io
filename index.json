var documents = [{"uri":"home","text":"SVG.js A lightweight library for manipulating and animating SVG. SVG.js has no dependencies and aims to be as small as possible while providing close to complete coverage of the SVG spec. Star  Not convinced yet? Here are a few highlights:  easy readable uncluttered syntax very small, about 16k gzipped animations on size, position, transformations, color, ... painless extension thanks to the modular structure various useful plugins available unified api between shape types with move, size, center, ... binding events to elements full support for opacity masks and clipping paths text paths, even animated element groups and sets dynamic gradients fully documented  License Svg.js is licensed under the terms of the MIT License. Changelog Wondering what has changed in the latest releases? Have a look at the change log."},{"uri":"installation","text":"Installation Download svg.js [for development] - lots of comments svg.min.js [for production] - \u00b116k when gzipped CDN.js Grab the latest version here from cdnjs.com. Bower bower install svg.js Node npm install svg.js"},{"uri":"usage","text":"Usage Create an SVG document Use the SVG() function to create an SVG document within a given html element: var draw = SVG('drawing').size(300, 300) var rect = draw.rect(100, 100).attr({ fill: '#f06' }) The first argument can either be an id of the element or the selected element itself. Be aware that the HTML element must exist before running the SVG.js code. Given this HTML:  This will generate the following output:              By default the svg drawing follows the dimensions of its parent, in this case #drawing: var draw = SVG('drawing').size('100%', '100%') Checking for SVG support By default this library assumes the client's browser supports SVG. You can test support as follows: if (SVG.supported) {   var draw = SVG('drawing')   var rect = draw.rect(100, 100) } else {   alert('SVG not supported') } SVG document Svg.js also works outside of the HTML DOM, inside an SVG document for example:                  Sub-pixel offset fix Call the spof() method to fix sub-pixel offset: var draw = SVG('drawing').spof() To enable automatic sub-pixel offset correction when the window is resized: SVG.on(window, 'resize', function() { draw.spof() })"},{"uri":"parents","text":"Parents The SVG.Parent prototype is the base wrapper for all elements that can contain other elements. SVG.Parent inherits directly from the lowest level of all SVG.js prototypes: SVG.Element. SVG.Container adds another level to the parent inheritance stack. Where SVG.Parent brings some low level methods like add(), remove() and has() to name a few, SVG.Container can and should be used if you want to add your won methods. That way the SVG.Parent prototype remains clean. Therefore you should always inherit from SVG.Container when implementing your own parent elements. The parent inheritance stack is: SVG.Element > SVG.Parent > SVG.Container."},{"uri":"parents\/main-svg-document","text":"Main svg document returns SVG.Doc which inherits from SVG.Container The main SVG.js initializer function creates a root svg node in the given element and returns an instance of SVG.Doc: var draw = SVG('drawing')"},{"uri":"parents\/groups","text":"Groups returns SVG.G which inherits from SVG.Container Grouping elements is useful if you want to transform a set of elements as if it were one. All element within a group maintain their position relative to the group they belong to. A group has all the same element methods as the root svg document: var group = draw.group() group.path('M10,20L30,40') Existing elements from the svg document can also be added to a group: group.add(rect) Note: Groups do not have a geometry of their own, it's inherited from their content. Therefore groups do not listen to x, y, width and height attributes. If that is what you are looking for, use a nested() svg instead."},{"uri":"parents\/nested-svg","text":"Nested svg returns SVG.Nested which inherits from SVG.Container With this feature you can nest svg documents within each other. Nested svg documents have exactly the same features as the main, top-level svg document: var nested = draw.nested()  var rect = nested.rect(200, 200)"},{"uri":"parents\/defs","text":"Defs returns SVG.Defs which inherits from SVG.Container The  element is a container element for referenced elements. Elements that are descendants of a \u2018defs\u2019 are not rendered directly. The  node lives in the main  document and can be accessed with the defs() method: var defs = draw.defs() The defs are also available on any other element through the doc() method: var defs = rect.doc().defs() The defs node works exactly the same as groups."},{"uri":"parents\/hyperlink","text":"Hyperlink returns SVG.A which inherits from SVG.Container A hyperlink or  tag creates a container that enables a link on all children: var link = draw.link('http:\/\/svgdotjs.github.io\/') var rect = link.rect(100, 100) The link url can be updated with the to() method: link.to('http:\/\/apple.com') Furthermore, the link element has a show() method to create the xlink:show attribute: link.show('replace') And the target() method to create the target attribute: link.target('_blank') Elements can also be linked the other way around with the linkTo() method: rect.linkTo('http:\/\/svgdotjs.github.io\/') Alternatively a block can be passed instead of a url for more options on the link element: rect.linkTo(function(link) {   link.to('http:\/\/svgdotjs.github.io\/').target('_blank') })"},{"uri":"elements","text":"Elements SVG.Element is the base prototype wrapping all elements (or nodes for that matter) in SVG.js. An extra level of refinement is added with SVG.Shape. Every element that can take a fill and\/or stroke attribute. It is preferred to extend elements with your own methods on SVG.Shape, rather than on SVG.Element."},{"uri":"elements\/rect","text":"Rect returns SVG.Rect which inherits from SVG.Shape Rects have two arguments, their width and height: var rect = draw.rect(100, 100) radius() returns itself Rects can also have rounded corners: rect.radius(10) This will set the rx and ry attributes to 10. To set rx and ry individually: rect.radius(10, 20)"},{"uri":"elements\/circle","text":"Circle returns SVG.Circle which inherits from SVG.Shape The only argument necessary for a circle is the diameter: var circle = draw.circle(100) radius() returns itself circle.radius(75)"},{"uri":"elements\/ellipse","text":"Ellipse returns SVG.Circle which inherits from SVG.Shape var ellipse = draw.ellipse(200, 100) radius() returns itself Ellipses can also be redefined by their radii: ellipse.radius(75, 50)"},{"uri":"elements\/line","text":"Line returns SVG.Line which inherits from SVG.Shape Create a line from point A to point B: var line = draw.line(0, 0, 100, 150).stroke({ width: 1 }) Creating a line element can be done in four ways. Look at the plot() method to see all the possibilities. plot() returns itself Updating a line is done with the plot() method: line.plot(50, 30, 100, 150) Alternatively it also accepts a point string: line.plot('0,0 100,150') Or a point array: line.plot([[0, 0], [100, 150]]) Or an instance of SVG.PointArray: var array = new SVG.PointArray([[0, 0], [100, 150]]) line.plot(array) array() returns SVG.PointArray References the SVG.PointArray instance. This method is rather intended for internal use: polyline.array()"},{"uri":"elements\/polyline","text":"Polyline returns SVG.Polyine which inherits from SVG.Shape The polyline element defines a set of connected straight line segments. Typically, polyline elements define open shapes: \/\/ polyline('x,y x,y x,y') var polyline = draw.polyline('0,0 100,50 50,100').fill('none').stroke({ width: 1 }) Polyline strings consist of a list of points separated by spaces: x,y x,y x,y. As an alternative an array of points will work as well: \/\/ polyline([[x,y], [x,y], [x,y]]) var polyline = draw.polyline([[0,0], [100,50], [50,100]]).fill('none').stroke({ width: 1 }) plot() returns itself Polylines can be updated using the plot() method: polyline.plot([[0,0], [100,50], [50,100], [150,50], [200,50]]) The plot() method can also be animated: polyline.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]]) array() returns SVG.PointArray References the SVG.PointArray instance. This method is rather intended for internal use: polyline.array()"},{"uri":"elements\/polygon","text":"Polygon returns SVG.Polygon which inherits from SVG.Shape The polygon element, unlike the polyline element, defines a closed shape consisting of a set of connected straight line segments: \/\/ polygon('x,y x,y x,y') var polygon = draw.polygon('0,0 100,50 50,100').fill('none').stroke({ width: 1 }) Polygon strings are exactly the same as polyline strings. There is no need to close the shape as the first and last point will be connected automatically. plot() returns itself Like polylines, polygons can be updated using the plot() method: polygon.plot([[0,0], [100,50], [50,100], [150,50], [200,50]]) The plot() method can also be animated: polygon.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]]) array() returns SVG.PointArray References the SVG.PointArray instance. This method is rather intended for internal use: polygon.array()"},{"uri":"elements\/path","text":"Path returns SVG.Path which inherits from SVG.Shape The path string is similar to the polygon string but much more complex in order to support curves: draw.path('M 100 200 C 200 100 300  0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100') For more details on path data strings, please refer to the SVG documentation on path data. plot() returns itself Paths can be updated using the plot() method: path.plot('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80') The plot() method can also be animated: path.animate(2000).plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80').loop(true, true) There is only basic support for animating paths baked into SVG.js, which means that only paths with the same commands (M,C,S etc.) are animatable. If you need to animate paths that does not share the same commands in order, you can use svg.pathmorphing.js array() returns SVG.PathArray References the SVG.PathArray instance. This method is rather intended for internal use: path.array() length() returns number Get the total length of a path element: var length = path.length() pointAt() returns object Get point on a path at given length: var point = path.pointAt(105) \/\/-> returns { x : 96.88497924804688, y : 58.062747955322266 }"},{"uri":"elements\/image","text":"Image returns SVG.Image which inherits from SVG.Shape Creating images is as you might expect: var image = draw.image('\/path\/to\/image.jpg') If you know the size of the image, those parameters can be passed as the second and third arguments: var image = draw.image('\/path\/to\/image.jpg', 200, 300) load() returns itself Loading another image can be done with the load() method: image.load('\/path\/to\/another\/image.jpg') loaded() returns itself If you don't know the size of the image, obviously you will have to wait for the image to be loaded: var image = draw.image('\/path\/to\/image.jpg').loaded(function(loader) {   this.size(loader.width, loader.height) }) The returned loader object as first the argument of the loaded method contains four values:  width height ratio (width \/ height) url "},{"uri":"elements\/text","text":"Text returns SVG.Text which inherits from SVG.Shape Unlike html, text in svg is much harder to tame. There is no way to create flowing text, so newlines should be entered manually. In SVG.js there are two ways to create text elements. The first and easiest method is to provide a string of text, split by newlines: var text = draw.text(\"Lorem ipsum dolor sit amet consectetur.\\nCras sodales imperdiet auctor.\") This will automatically create a block of text and insert newlines where necessary. The second method will give you much more control but requires a bit more code: var text = draw.text(function(add) {   add.tspan('Lorem ipsum dolor sit amet ').newLine()   add.tspan('consectetur').fill('#f06')   add.tspan('.')   add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)   add.tspan('Nunc ultrices lectus at erat').newLine()   add.tspan('dictum pharetra elementum ante').newLine() }) If you want to go the other way and don't want to add tspans at all, just one line of text, you can use the plain() method instead: var text = draw.plain('Lorem ipsum dolor sit amet consectetur.') This is a shortcut to the plain method on the SVG.Text instance which doesn't render newlines at all. text() as setter returns itself Changing text afterwards is also possible with the text() method: text.text('Brilliant!') text() as getter returns string To get the raw text content: text.text() tspan() returns SVG.Tspan Just adding one tspan is also possible: text.tspan(' on a train...').fill('#f06') plain() returns itself If the content of the element doesn't need any stying or multiple lines, it might be sufficient to just add some plain text: text.plain('I do not have any expectations.') font() returns itself The sugar.js module provides some syntax sugar specifically for this element type: text.font({   family:   'Helvetica' , size:     144 , anchor:   'middle' , leading:  '1.5em' }) leading() returns itself As opposed to html, where leading is defined by line-height, svg does not have a natural leading equivalent. In svg, lines are not defined naturally. They are defined by  nodes with a dy attribute defining the line height and a x value resetting the line to the x position of the parent text element. But you can also have many nodes in one line defining a different y, dy, x or even dx value. This gives us a lot of freedom, but also a lot more responsibility. We have to decide when a new line is defined, where it starts, what its offset is and what it's height is. The leading() method in SVG.js tries to ease the pain by giving you behaviour that is much closer to html. In combination with newline separated text, it works just like html: var text = draw.text(\"Lorem ipsum dolor sit amet consectetur.\\nCras sodales imperdiet auctor.\") text.leading(1.3) This will render a text element with a tspan element for each line, with a dy value of 130% of the font size. Note that the leading() method assumes that every first level tspan in a text node represents a new line. Using leading() on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambeled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the newLine() method on every first level tspan added in the block passed as argument to the text element. build() returns itself The build() can be used to enable \/ disable build mode. With build mode disabled, the plain() and tspan() methods will first call the clear() bethod before adding the new content. So when build mode is enabled, plain() and tspan() will append the new content to the existing content. When passing a block to the text() method, build mode is toggled automatically before and after the block is called. But in some cases it might be useful to be able to toggle it manually: var text = draw.text('This is just the start, ')  text.build(true)  \/\/ enables build mode  var tspan = text.tspan('something pink in the middle ').fill('#00ff97') text.plain('and again boring at the end.')  text.build(false) \/\/ disables build mode  tspan.animate('2s').fill('#f06') rebuild() returns itself This is an internal callback that probably never needs to be called manually. Basically it rebuilds the text element whenerver font-size and x attributes or the leading() of the text element are modified. This method also acts a setter to enable or disable rebuilding: text.rebuild(false) \/\/-> disables rebuilding text.rebuild(true)  \/\/-> enables rebuilding and instantaneously rebuilds the text element clear() returns itself Clear all the contents of the called text element: text.clear() length() returns number Gets the total computed text length of all tspans together: text.length() lines() returns SVG.Set All first level tspans can be referenced with the lines() method: text.lines() This will return an intance of SVG.Set including all tspan elements. events The text element has one event. It is fired every time the rebuild() method is called: text.on('rebuild', function() {   \/\/ whatever you need to do after rebuilding })"},{"uri":"elements\/tspan","text":"Tspan returns SVG.Tspan which inherits from SVG.Shape The tspan elements are only available inside text elements or inside other tspan elements. text() returns itself Update the content of the tspan. This can be done by either passing a string: tspan.text('Just a string.') Which will basicly call the plain() method. Or by passing a block to add more specific content inside the called tspan: tspan.text(function(add) {   add.plain('Just plain text.')   add.tspan('Fancy text wrapped in a tspan.').fill('#f06')   add.tspan(function(addMore) {     addMore.tspan('And you can doo deeper and deeper...')   }) }) tspan() returns SVG.Tspan Add a nested tspan: tspan.tspan('I am a child of my parent').fill('#f06') plain() returns itself Just adds some plain text: tspan.plain('I do not have any expectations.') dx() returns itself Define the dynamic x value of the element, much like a html element with position:relative and left defined: tspan.dx(30) dy() returns itself Define the dynamic y value of the element, much like a html element with position:relative and top defined: tspan.dy(30) newLine() returns itself The newLine() is a convenience method for adding a new line with a dy attribute using the current \"leading\": var text = draw.text(function(add) {   add.tspan('Lorem ipsum dolor sit amet ').newLine()   add.tspan('consectetur').fill('#f06')   add.tspan('.')   add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)   add.tspan('Nunc ultrices lectus at erat').newLine()   add.tspan('dictum pharetra elementum ante').newLine() }) clear() returns itself Clear all the contents of the called tspan element: tspan.clear() length() returns number Gets the total computed text length: tspan.length()"},{"uri":"elements\/textpath","text":"TextPath returns SVG.TextPath which inherits from SVG.Shape A nice feature in svg is the ability to run text along a path: var text = draw.text(function(add) {   add.tspan('We go ')   add.tspan('up').fill('#f09').dy(-40)   add.tspan(', then we go down, then up again').dy(40) }) text   .path('M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')   .font({ size: 42.5, family: 'Verdana' }) When calling the path() method on a text element, the text element is mutated into an intermediate between a text and a path element. From that point on the text element will also feature a plot() method to update the path: text.plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100') Attributes specific to the  element can be applied to the textPath instance itself: text.textPath().attr('startOffset', 0.5) And they can be animated as well of course: text.textPath().animate(3000).attr('startOffset', 0.8) textPath() returns SVG.TextPath Referencing the textPath node directly: var textPath = text.textPath() track() returns SVG.Path Referencing the linked path element directly: var path = text.track()"},{"uri":"elements\/use","text":"Use returns SVG.Use which inherits from SVG.Shape The use element simply emulates another existing element. Any changes on the master element will be reflected on all the use instances. The usage of use() is very straightforward: var rect = draw.rect(100, 100).fill('#f09') var use  = draw.use(rect).move(200, 200) In the case of the example above two rects will appear on the svg drawing, the original and the use instance. In some cases you might want to hide the original element. the best way to do this is to create the original element in the defs node: var rect = draw.defs().rect(100, 100).fill('#f09') var use  = draw.use(rect).move(200, 200) In this way the rect element acts as a library element. You can edit it but it won't be rendered. Another way is to point an external SVG file, just specified the element id and path to file. var use  = draw.use('elementId', 'path\/to\/file.svg') This way is useful when you have complex images already created. Note that, for external images (outside your domain) it may be necessary to load the file with XHR."},{"uri":"elements\/symbol","text":"Symbol returns SVG.Bare which inherits from SVG.Element Not unlike the group element, the symbol element is a container element. The only difference between symbols and groups is that symbols are not rendered. Therefore a symbol element is ideal in combination with the use element: var symbol = draw.symbol() symbol.rect(100, 100).fill('#f09')  var use  = draw.use(symbol).move(200, 200)"},{"uri":"elements\/gradient","text":"Gradient gradient() returns SVG.Gradient There are linear and radial gradients. The linear gradient can be created like this: var gradient = draw.gradient('linear', function(stop) {   stop.at(0, '#333')   stop.at(1, '#fff') }) at() returns itself The offset and color parameters are required for stops, opacity is optional. Offset is float between 0 and 1, or a percentage value (e.g. 33%). stop.at(0, '#333') or stop.at({ offset: 0, color: '#333', opacity: 1 }) from() returns itself To define the direction you can set from x, y and to x, y: gradient.from(0, 0).to(0, 1) The from and to values are also expressed in percent. to() returns itself To define the direction you can set from x, y and to x, y: gradient.from(0, 0).to(0, 1) The from and to values are also expressed in percent. radius() returns itself Radial gradients have a radius() method to define the outermost radius to where the inner color should develop: var gradient = draw.gradient('radial', function(stop) {   stop.at(0, '#333')   stop.at(1, '#fff') })  gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5) update() returns itself A gradient can also be updated afterwards: gradient.update(function(stop) {   stop.at(0.1, '#333', 0.2)   stop.at(0.9, '#f03', 1) }) And even a single stop can be updated: var s1, s2, s3  draw.gradient('radial', function(stop) {   s1 = stop.at(0, '#000')   s2 = stop.at(0.5, '#f03')   s3 = stop.at(1, '#066') })  s1.update(0.1, '#0f0', 1) get() returns SVG.Stop The get() method makes it even easier to get a stop from an existing gradient: var gradient = draw.gradient('radial', function(stop) {   stop.at({ offset: 0, color: '#000', opacity: 1 })   \/\/ -> first   stop.at({ offset: 0.5, color: '#f03', opacity: 1 }) \/\/ -> second   stop.at({ offset: 1, color: '#066', opacity: 1 })   \/\/ -> third })  var s1 = gradient.get(0) \/\/ -> returns \"first\" stop fill() as getter returns value gradient.fill() \/\/-> returns 'url(#SvgjsGradient1234)' fill() as setter returns itself Finally, to use the gradient on an element: rect.attr({ fill: gradient }) Or: rect.fill(gradient) By passing the gradient instance as the fill on any element, the fill() method will be called: MDN has a great example page on how SVG Gradients work."},{"uri":"elements\/pattern","text":"Pattern pattern() returns SVG.Pattern Creating a pattern is very similar to creating gradients: var pattern = draw.pattern(20, 20, function(add) {   add.rect(20,20).fill('#f06')   add.rect(10,10)   add.rect(10,10).move(10,10) }) This creates a checkered pattern of 20 x 20 pixels. You can add any available element to your pattern. update() returns itself A pattern can also be updated afterwards: pattern.update(function(add) {   add.circle(15).center(10,10) }) fill() as setter returns value Finally, to use the pattern on an element: rect.attr({ fill: pattern }) Or: rect.fill(pattern) By passing the pattern instance as the fill on any element, the fill() method will be called on the pattern instance. fill() as getter pattern.fill() \/\/-> returns 'url(#SvgjsPattern1234)'"},{"uri":"elements\/marker","text":"Marker marker() Markers can be added to every individual point of a line, polyline, polygon and path. There are three types of markers: start, mid and end. Where start represents the first point, end the last and mid every point in between. var path = draw.path('M 100 200 C 200 100 300  0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100z')  path.fill('none').stroke({ width: 1 })  path.marker('start', 10, 10, function(add) {   add.circle(10).fill('#f06') }) path.marker('mid', 10, 10, function(add) {   add.rect(10, 10) }) path.marker('end', 20, 20, function(add) {   add.circle(6).center(4, 5)   add.circle(6).center(4, 15)   add.circle(6).center(16, 10)    this.fill('#0f6') }) The marker() method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times so it will create a marker in the defs but not show it yet: var marker = draw.marker(10, 10, function(add) {   add.rect(10, 10) }) Secondly a marker can be created and applied directly on its target element: path.marker('start', 10, 10, function(add) {   add.circle(10).fill('#f06') }) This will create a marker in the defs and apply it directly. Note that the first argument defines the position of the marker and that there are four arguments as opposed to three with the first example. Lastly, if a marker is created for reuse on a container element, it can be applied directly on the target element: path.marker('mid', marker) Finally, to get a marker instance from the target element reference: path.reference('marker-end') ref() returns itself By default the refX and refY attributes of a marker are set to respectively half the width nd height values. To define the refX and refY of a marker differently: marker.ref(2, 7) update() returns itself Updating the contents of a marker will clear() the existing content and add the content defined in the block passed as the first argument: marker.update(function(add) {   add.circle(10) }) width() returns itself Defines the markerWidth attribute: marker.width(10) height() returns itself Defines the markerHeight attribute: marker.height(10) size() returns itself Defines the markerWidth and markerHeight attributes: marker.size(10, 10)"},{"uri":"elements\/bare","text":"Bare returns SVG.Bare which inherits from SVG.Element For all SVG elements that are not described by SVG.js, the SVG.Bare class comes in handy. This class inherits directly from SVG.Element and makes it possible to add custom methods in a separate namespace without polluting the main SVG.Element namespace. Consider it your personal playground. element() returns SVG.Bare The SVG.Bare class can be instantiated with the element() method on any parent element: var element = draw.element('title') The string value passed as the first argument is the node name that should be generated. Additionally any existing class name can be passed as the second argument to define from which class the element should inherit: var element = draw.element('symbol', SVG.Parent) This gives you as the user a lot of power. But remember, with great power comes great responsibility. words() returns itself The SVG.Bare instance carries an additional method to add plain text: var element = draw.element('title').words('This is a title.') \/\/-> This is a title."},{"uri":"referencing","text":"Referencing By id returns SVG.Element (or the most relevant subclass of SVG.Element) If you want to get an element created by SVG.js by its id, you can use the SVG.get() method: var element = SVG.get('my_element')  element.fill('#f06') Using CSS selectors returns SVG.Set There are two ways to select elements using CSS selectors. The first is to search globally. This will search in all svg elements in a document and return them in an instance of SVG.Set: var elements = SVG.select('rect.my-class').fill('#f06') The second is to search within a parent element: var elements = group.select('rect.my-class').fill('#f06') Using jQuery or Zepto Another way is to use jQuery or Zepto. Here is an example: \/\/ add elements var draw   = SVG('drawing') var group  = draw.group().addClass('my-group') var rect   = group.rect(100,100).addClass('my-element') var circle = group.circle(100).addClass('my-element').move(100, 100)  \/\/ get elements in group var elements = $('#drawing g.my-group .my-element').each(function() {   this.instance.animate().fill('#f09') })"},{"uri":"referencing\/circular-reference","text":"Circular reference Every element instance within SVG.js has a reference to the actual node: node returns node element.node native() returns node The same can be achieved with the native() method: element.native() instance returns element Similarly, the node carries a reference to the SVG.js instance: node.instance"},{"uri":"referencing\/parent-references","text":"Parent reference Every element has a reference to its parent with the parent() method: parent() within the svg document returns SVG.Element element.parent() Alternatively a class or css selector can be passed as the first argument: var draw   = SVG('drawing') var nested = draw.nested().addClass('test') var group  = nested.group() var rect   = group.rect(100, 100)  rect.parent()           \/\/-> returns group rect.parent(SVG.Doc)    \/\/-> returns draw rect.parent(SVG.Nested) \/\/-> returns nested rect.parent(SVG.G)      \/\/-> returns group rect.parent('.test')    \/\/-> returns nested parent() on the topmost svg document returns HTMLNode var draw = SVG('drawing')  draw.parent() \/\/-> returns the wrappig html element with id 'drawing' doc() returns SVG.Doc For retrieving the root svg you can use doc() var draw = SVG('drawing') var rect = draw.rect(100, 100)  rect.doc() \/\/-> returns draw parents() returns Array To get all ancestors of the element filtered by type or css selector (see parent() method) var group1 = draw.group().addClass('test')   , group2 = group1.group()   , rect   = group2.rect(100,100)  rect.parents()        \/\/ returns [group1, group2, draw] rect.parents('.test') \/\/ returns [group1] rect.parents(SVG.G)   \/\/ returns [group1, group2]"},{"uri":"referencing\/child-references","text":"Child references first() returns SVG.Element To get the first child of a parent element: draw.first() last() returns SVG.Element To get the last child of a parent element: draw.last() children() returns array An array of all children will can be retrieves with the children method: draw.children() each() returns itself The each() allows you to iterate over the all children of a parent element: draw.each(function(i, children) {   this.fill({ color: '#f06' }) }) Deep traversing is also possible by passing true as the second argument: \/\/ draw.each(block, deep) draw.each(function(i, children) {   this.fill({ color: '#f06' }) }, true) Note that this refers to the current child element. has() returns boolean Checking the existence of an element within a parent: var rect  = draw.rect(100, 50) var group = draw.group()  draw.has(rect)  \/\/-> returns true group.has(rect) \/\/-> returns false index() returns number Returns the index of given element and returns -1 when it is not a child: var rect  = draw.rect(100, 50) var group = draw.group()  draw.index(rect)  \/\/-> returns 0 group.index(rect) \/\/-> returns -1 get() returns SVG.Element Get an element on a given position in the children array: var rect   = draw.rect(20, 30) var circle = draw.circle(50)  draw.get(0) \/\/-> returns rect draw.get(1) \/\/-> returns circle clear() returns itself To remove all elements from a parent element: draw.clear()"},{"uri":"manipulating","text":"Manipulating Everything you need to know about manipulating elements using their attributes."},{"uri":"manipulating\/attributes","text":"Attributes attr() as getter returns value (string, number, ...) You can get and set an element's attributes directly using attr(). Get a single attribute: var x = rect.attr('x') Get all attributes as an object: var attributes = rect.attr() attr() as setter returns itself Set a single attribute: rect.attr('x', 50) Set multiple attributes at once: rect.attr({   fill: '#f06' , 'fill-opacity': 0.5 , stroke: '#000' , 'stroke-width': 10 }) Set an attribute with a namespace: rect.attr('x', 50, 'http:\/\/www.w3.org\/2000\/svg') Explicitly remove an attribute: rect.attr('fill', null)"},{"uri":"manipulating\/transforms","text":"Transforms transform() as getter returns value The transform() method acts as a full getter without an argument: element.transform() The returned object contains the following values:  x (translation on the x-axis) y (translation on the y-axis) skewX (calculated skew on x-axis) skewY (calculated skew on y-axis) scaleX (calculated scale on x-axis) scaleY (calculated scale on y-axis) rotation (calculated rotation) cx (last used rotation centre on x-axis) cy (last used rotation centre on y-axis)  Additionally a string value for the required property can be passed: element.transform('rotation') transform() as setter returns itself As a setter it has two ways of working. By default transformations are absolute. For example, if you call: element.transform({ rotation: 125 }).transform({ rotation: 37.5 }) The resulting rotation will be 37.5 and not the sum of the two transformations. But if that's what you want there is a way out by adding the relative parameter. That would be: element.transform({ rotation: 125 }).transform({ rotation: 37.5, relative: true }) Alternatively a relative flag can be passed as the second argument: element.transform({ rotation: 125 }).transform({ rotation: 37.5 }, true) Available transformations are:  rotation with optional cx and cy scale with optional cx and cy scaleX with optional cx and cy scaleY with optional cx and cy skewX with optional cx and cy skewY with optional cx and cy x y a, b, c, d, e and\/or f or an existing matrix instead of the object  rotate() returns itself The rotate() method will automatically rotate elements according to the center of the element: \/\/ rotate(degrees) rect.rotate(45) Although you can also define a specific rotation point: \/\/ rotate(degrees, cx, cy) rect.rotate(45, 50, 50) skew() returns itself The skew() method will take an x and y value: \/\/ skew(x, y) rect.skew(0, 45) scale() returns itself The scale() method will take an x and y value: \/\/ scale(x, y) rect.scale(0.5, -1) translate() returns itself The translate() method will take an x and y value: \/\/ translate(x, y) rect.translate(0.5, -1)"},{"uri":"manipulating\/styles","text":"Styles style() as getter returns value (string, number, ...) Similar to attr() the style() method can also act as a getter: rect.style('cursor') \/\/ => pointer Or even a full getter: rect.style() \/\/ => 'cursor:pointer;fill:#f03;' style() as setter returns itself With the style() method the style attribute can be managed like attributes with attr: rect.style('cursor', 'pointer') Multiple styles can be set at once using an object: rect.style({ cursor: 'pointer', fill: '#f03' }) Or a css string: rect.style('cursor:pointer;fill:#f03;') Explicitly deleting individual style definitions works the same as with the attr() method: rect.style('cursor', null)"},{"uri":"manipulating\/classes","text":"Class Names classes() returns array Fetches the css classes for the node as an array: rect.classes() hasClass() returns boolean Test the presence of a given css class: rect.hasClass('purple-rain') addClass() returns itself Adds a given css class: rect.addClass('pink-flower') removeClass() returns itself Removes a given css class: rect.removeClass('pink-flower') toggleClass() returns itself Toggles a given css class: rect.toggleClass('pink-flower')"},{"uri":"manipulating\/position","text":"Position While positioning an element by directly setting its attributes works only if the attributes are used natively by that type of element, the positioning methods described below are much more convenient as they work for all element types. For example, the following code works because each element is positioned by setting native attributes: rect.attr({ x: 20, y: 60 }) circle.attr({ cx: 50, cy: 40 }) The rect will be moved by its upper left corner to the new coordinates, and the circle will be moved by its center. However, trying to move a circle by its 'corner' or a rect by its center in this way will fail. The following lines will get silently ignored as the attributes that are addressed are not natively used by the element setting them: rect.attr({ cx: 20, cy: 60 }) circle.attr({ x: 50, y: 40 }) However, the positioning methods detailed below will work for all element types, regardless of whether the attributes being addressed are native to the type. So, unlike the lines above, these lines work just fine: rect.cx(20).cy(60) circle.x(50).y(40) It is important to note, though, that these methods are only intended for use with user (unitless) coordinates. If, for example, an element has its size set via percentages or other units, the positioning methods that address its native attributes will most likely still work, but the ones that address non-native attributes will give unexpected results -- as both getters and setters! move() returns itself Move the element by its upper left corner to a given x and y position: rect.move(200, 350) x() as getter returns value Without an argument the x() method serves as a getter: var x = rect.x() x() as setter returns itself Move the element by its upper left corner along the x-axis only: rect.x(200) y() as getter returns value Without an argument the y() method serves as a getter: var y = rect.y() y() as setter returns itself Move the element by its upper left corner along the y-axis only: rect.y(350) center() returns itself Move the element by its center to a given cx and cy position: rect.center(150, 150) cx() as getter returns value Without an argument the cx() method serves as a getter: var cx = rect.cx() cx() as setter returns itself Move the element by its center in the x direction only: rect.cx(200) cy() as getter returns value Without an argument the cy() method serves as a getter as well: var cy = rect.cy() cy() as setter returns itself Move the element by its center in the y direction only: rect.cy(350) dmove() returns itself Shift the element in both the x and y directions relative to its current position: rect.dmove(10, 30) dx() returns itself Shift the element in the x direction relative to its current position: rect.dx(200) dy() returns itself Shift the element in the y direction relative to its current position: rect.dy(200)"},{"uri":"manipulating\/size","text":"Size size() returns itself Set the size of an element to a given width and height: rect.size(200, 300) Proportional resizing is also possible by leaving out height: rect.size(200) Or by passing null as the value for width: rect.size(null, 200) As with positioning, the size of an element could be set by using attr(). But because every type of element is handles its size differently the size() method is much more convenient. There is one exception though: for SVG.Text elements, this method takes only one argument and applies the given value to the font-size attribute. width() as getter returns value var width = rect.width() width() as setter returns itself Set the width of an element: rect.width(200) height() as getter returns value rect.height() height() as setter returns itself Set the height of an element: rect.height(325) radius() returns itself Circles, ellipses, and rects may use the radius() method. On rects, it defines rounded corners. For a circle, the argument sets the r attribute. circle.radius(10) For ellipses and rects, pass two arguments to set the rx and ry attributes individually. Or, pass a single argument, to make the two attributes equal. ellipse.radius(10, 20) rect.radius(5)"},{"uri":"manipulating\/document-tree","text":"Document Tree clone() returns SVG.Element To make an exact copy of an element the clone() method comes in handy: var clone = rect.clone() This will create a new, unlinked copy. For making a linked clone, see the use element. By default the cloned element is placed directly after the orginal element. When you pass a parent parameter to the clone() function it will append the cloned element to the given parent. remove() returns itself Removes the calling element from the svg document: rect.remove() replace() returns SVG.Element At the calling element's position in the svg document, replace the calling element with the element passed to the method. rect.replace(draw.circle(100)) add() returns itself Sets the calling element as the parent node of the argument. Returns the parent: var rect = draw.rect(100, 100) var group = draw.group()  group.add(rect) \/\/-> returns group put() returns SVG.Element Sets the calling element as the parent node of the argument. Returns the child: group.put(rect) \/\/-> returns rect addTo() returns itself Sets the calling element as a child node of the argument. Returns the child: rect.addTo(group) \/\/-> returns rect putIn() returns SVG.Element Sets the calling element as a child node of the argument. Returns the parent: rect.putIn(group) \/\/-> returns group toParent() returns itself Moves an element to a different parent (similar to addTo), but without changing its visual representation. All transformations are merged and applied to the element. rect.toParent(group) \/\/ looks the same as before toDoc() returns itself Same as toParent() but with the root-node as parent ungroup() \/ flatten() returns itself Break up a group\/container and move all the elements to a given parent node without changing their visual representations. The result is a flat svg structure, e.g. for exporting. \/\/ ungroups all elements in this group recursively and places them into the given parent \/\/ (default: parent container of the calling element) group.ungroup(parent, depth)  \/\/ call it on the whole document to get a flat svg structure drawing.ungroup()  \/\/ breaks up the group and places all elements in drawing group.ungroup(drawing)  \/\/ breaks up all groups until it reaches a depth of 3 drawing.ungroup(null, 3)  \/\/ flat and export svg var svgString = drawing.ungroup().svg()"},{"uri":"manipulating\/arranging","text":"Arranging You can arrange elements within their parent SVG document using the following methods. front() returns itself Move element to the front: rect.front() back() returns itself Move element to the back: rect.back() forward() returns itself Move element one step forward: rect.forward() backward() returns itself Move element one step backward: rect.backward() siblings() returns array The arrange.js module brings some additional methods. To get all siblings of rect, including rect itself: rect.siblings() position() returns number Get the position (a number) of rect between its siblings: rect.position() next() returns SVG.Element Get the next sibling: rect.next() previous() returns SVG.Element Get the previous sibling: rect.previous() before() returns itself Insert an element before another: \/\/ inserts circle before rect rect.before(circle) after() returns itself Insert an element after another: \/\/ inserts circle after rect rect.after(circle)"},{"uri":"manipulating\/masking","text":"Masking elements maskWith() returns itself The easiest way to mask is to use a single element: var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })  rect.maskWith(ellipse) mask() returns SVG.Mask But you can also use multiple elements: var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' }) var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 }).fill({ color: '#fff' })  var mask = draw.mask().add(text).add(ellipse)  rect.maskWith(mask) If you want the masked object to be rendered at 100% you need to set the fill color of the masking object to white. But you might also want to use a gradient: var gradient = draw.gradient('linear', function(stop) {   stop.at({ offset: 0, color: '#000' })   stop.at({ offset: 1, color: '#fff' }) })  var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })  rect.maskWith(ellipse) unmask() returns itself Unmasking the elements can be done with the unmask() method: rect.unmask() The unmask() method returns the masking element. remove() returns itself Removing the mask altogether will also unmask() all masked elements as well: mask.remove() masker returns SVG.Mask For your convenience, the masking element is also referenced in the masked element. This can be useful in case you want to change the mask: rect.masker.fill('#fff')"},{"uri":"manipulating\/clipping","text":"Clipping Clipping elements works exactly the same as masking elements. The only difference is that clipped elements will adopt the geometry of the clipping element. Therefore events are only triggered when entering the clipping element whereas with masks the masked element triggers the event. Another difference is that masks can define opacity with their fill color and clipPaths don't. clipWith() returns itself var ellipse = draw.ellipse(80, 40).move(10, 10)  rect.clipWith(ellipse) clip() returns SVG.ClipPath Clip multiple elements: var ellipse = draw.ellipse(80, 40).move(10, 10) var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 })  var clip = draw.clip().add(text).add(ellipse)  rect.clipWith(clip) unclip() returns itself Unclipping the elements can be done with the unclip() method: rect.unclip() remove() returns itself Removing the clip alltogether will also unclip() all clipped elements as well: clip.remove() clipper returns SVG.ClipPath For your convenience, the clipping element is also referenced in the clipped element. This can be useful in case you want to change the clipPath: rect.clipper.move(10, 10)"},{"uri":"manipulating\/misc","text":"Misc point() returns SVG.Point Transforms a point from screen coordinates to the elements coordinate system. \/\/ e is some mouseevent var point = path.point(e.screenX, e.screenY) \/\/ {x, y} inside() returns boolean To check if a given point is inside the bounding box of an element you can use the inside() method: var rect = draw.rect(100, 100).move(50, 50)  rect.inside(25, 30) \/\/-> returns false rect.inside(60, 70) \/\/-> returns true Note: the x and y positions are tested against the relative position of the element. Any offset on the parent element is not taken into account."},{"uri":"manipulating\/syntactic-sugar","text":"Syntactic sugar fill() returns itself The fill() method is a pretty alternative to the attr() method: rect.fill({ color: '#f06', opacity: 0.6 }) A single hex string will work as well: rect.fill('#f06') Last but not least, you can also use an image as fill, simply by passing an image url: rect.fill('images\/shade.jpg') Or if you want more control over the size of the image, you can pass an image instance as well: rect.fill(draw.image('images\/shade.jpg', 20, 20)) stroke() The stroke() method is similar to fill(): rect.stroke({ color: '#f06', opacity: 0.6, width: 5 }) Like fill, a single hex string will work as well: rect.stroke('#f06') Not unlike the fill() method, you can also use an image as stroke, simply by passing an image url: rect.stroke('images\/shade.jpg') Or if you want more control over the size of the image, you can pass an image instance as well: rect.stroke(draw.image('images\/shade.jpg', 20, 20)) returns: itself opacity() To set the overall opacity of an element: rect.opacity(0.5) returns: itself reference() In cases where an element is linked to another element through an attribute, the linked element instance can be fetched with the reference() method. The only thing required is the attribute name: use.reference('href') \/\/-> returns used element instance \/\/ or rect.reference('fill') \/\/-> returns gradient or pattern instance for example \/\/ or circle.reference('clip-path') \/\/-> returns clip instance hide() Hide element: rect.hide() returns: itself show() Show element: rect.show() returns: itself visible() To check if the element is visible: rect.visible() returns: boolean"},{"uri":"geometry","text":"Boxes Getting a bounding box of an element is often influenced by context. SVG.js offers various methods to get a bounding box of an element. All SVG.*Boxinstances have one method in common: merge(). merge() returns itself All SVG.*Box prototypes have a nifty little feature. With merge(), two SVG.*Box instances can be merged into one new instance, basically being the bounding box of the two original boxes. For example: var box1 = draw.rect(100,100).move(50,50).bbox() var box2 = draw.rect(100,100).move(200,200).bbox() var box3 = box1.merge(box2)"},{"uri":"geometry\/viewbox","text":"ViewBox viewbox() as getter returns SVG.ViewBox Without any arguments an instance of SVG.ViewBox will be returned: var box = draw.viewbox() But the best thing about the viewbox() method is that you can get the zoom of the viewbox: var box = draw.viewbox() var zoom = box.zoom If the size of the viewbox equals the size of the svg drawing, the zoom value will be 1. viewbox() as setter returns itself The viewBox attribute of an  element can be managed with the viewbox() method. When supplied with four arguments it will act as a setter: draw.viewbox(0, 0, 297, 210) Alternatively you can also supply an object as the first argument: draw.viewbox({ x: 0, y: 0, width: 297, height: 210 })"},{"uri":"geometry\/bbox","text":"BBox bbox() returns SVG.BBox Get the bounding box of an element. This is a wrapper for the native getBBox() method but adds more values: path.bbox() This will return an instance of SVG.BBox containing the following values:  width (value from native getBBox) height (value from native getBBox) w (shorthand for width) h (shorthand for height) x (value from native getBBox) y (value from native getBBox) cx (center x of the bounding box) cy (center y of the bounding box) x2 (lower right x of the bounding box) y2 (lower right y of the bounding box) "},{"uri":"geometry\/rbox","text":"RBox rbox() returns SVG.RBox Is similar to bbox() but will give you the box around the exact visual representation of the element, taking all transformations into account. path.rbox() This will return an instance of SVG.RBox containing the following values:  width (the actual visual width) height (the actual visual height) w (shorthand for width) h (shorthand for height) x (the actual visual position on the x-axis) y (the actual visual position on the y-axis) cx (center x of the bounding box) cy (center y of the bounding box) x2 (lower right x of the bounding box) y2 (lower right y of the bounding box)  Important: Mozilla browsers include stroke widths where other browsers do not. Therefore the resulting box might be different in Mozilla browsers. It is very hard to modify this behavior so for the time being this is an inconvenience we have to live with."},{"uri":"geometry\/tbox","text":"TBox tbox() returns SVG.TBox Where bbox() returns a bounding box mindless of any transformations, the tbox() method does take transformations into account. So any translation or scale will be applied to the resulting values to get closer to the actual visual representation: path.tbox() This will return an instance of SVG.TBox containing the following values:  width (value from native getBBox influenced by the scaleX of the current matrix) height (value from native getBBox influenced by the scaleY of the current matrix) w (shorthand for width) h (shorthand for height) x (value from native getBBox influenced by the x of the current matrix) y (value from native getBBox influenced by the y of the current matrix) cx (center x of the bounding box) cy (center y of the bounding box) x2 (lower right x of the bounding box) y2 (lower right y of the bounding box)  Note that the rotation of the element will not be added to the calculation."},{"uri":"animating","text":"Animating Method chain Note that the animate() method will not return the targeted element but an instance of SVG.FX which will take the following methods: Of course attr(): rect.animate().attr({ fill: '#f03' }) The x(), y() and move() methods: rect.animate().move(100, 100) And the cx(), cy() and center() methods: rect.animate().center(200, 200) If you include the sugar.js module, fill(), stroke(), rotate(), skew(), scale(), matrix(), opacity(), radius() will be available as well: rect.animate().rotate(45).skew(25, 0) You can also animate non-numeric unit values using the attr() method: rect.attr('x', '10%').animate().attr('x', '50%') Easing All available ease types are:  : ease in and out >: ease out "},{"uri":"animating\/animate","text":"Animate Animating elements is very much the same as manipulating elements using the attr() method. The only difference is you have to include the animate() method. animate() returns SVG.FX rect.animate().move(150, 150) The animate() method will take three arguments. The first is duration, the second ease and the third delay: rect.animate(2000, '>', 1000).attr({ fill: '#f03' }) Alternatively you can pass an object as the first argument: rect.animate({ ease: '"},{"uri":"animating\/controlling","text":"Controlling play() returns itself Will start playing a paused animation: rect.animate().move(200, 200)  rect.mouseover(function() { this.pause() }) rect.mouseout(function() { this.play() }) pause() returns itself Pausing an animations is fairly straightforward: rect.animate().move(200, 200)  rect.mouseover(function() { this.pause() }) stop() returns itself If you just want to stop an animation you can call the stop() method which has two optional arguments:  jumpToEnd: Sets the values to the end of the animation clearQueue: Remove all items from queue  rect.animate().move(200, 200)  rect.stop() \/\/ or e.g. rect.stop(true) Stopping an animation is irreversable. finish() returns itself This method finishes the whole animation chain. All values are set to their corresponding end values and every situation gets fullfilled rect.animate().move(200, 200).animate().dmove(50,50).size(300,400)  rect.finish() \/\/ rect at 250,250 with size 300,400 reverse() returns itself Toggles the direction of the animation or sets it to a specific direction: \/\/ will run from 100,100 to rects initial position rect.animate(3000).move(100, 100).reverse()  \/\/ sets direction to backwards rect.animate(3000).move(100, 100).reverse(true)  \/\/ sets direction to forwards (same as not calling reverse ever) rect.animate(3000).move(100, 100).reverse(false)"},{"uri":"animating\/timing","text":"Timing delay() returns itself Alternatively, you can call delay() which will set a delay in ms before the next animation in the queue is run rect.animate({ ease: '"},{"uri":"animating\/callbacks","text":"Callbacks during \/ duringAll() returns itself If you want to perform your own actions during one\/all animation you can use the during()\/duringAll() method: var position   , from = 100   , to   = 300  rect.animate(3000).move(100, 100).during(function(pos, morph, eased, situation) {   position = from + (to - from) * pos })  \/\/ or rect.animate(3000).move(100, 100).duringAll(function(pos, morph, eased, situation) {   position = from + (to - from) * pos }) Note that pos is 0 in the beginning of the animation and 1 at the end of the animation. To make things easier a morphing function is passed as the second argument. This function accepts a from and to value as the first and second argument and they can be a number, unit or hex color: var ellipse = draw.ellipse(100, 100).attr('cx', '20%').fill('#333')  rect.animate(3000).move(100, 100).during(function(pos, morph, eased, situation) {   \/\/ numeric values   ellipse.size(morph(100, 200), morph(100, 50))    \/\/ unit strings   ellipse.attr('cx', morph('20%', '80%'))    \/\/ hex color strings   ellipse.fill(morph('#333', '#ff0066')) }) The eased parameter contains the position after the easing function was applied. The last parameter holds the current situation related to the current during call. You can call during()\/duringAll() multiple times to add more functions which should be executed. after \/ afterAll() returns itself Furthermore, you can add callback methods using after()\/afterAll(): rect.animate(3000).move(100, 100).after(function(situation) {   this.animate().attr({ fill: '#f06' }) })  \/\/ or rect.animate(3000).move(100, 100).afterAll(function() {   this.animate().attr({ fill: '#f06' }) }) The function gets the situation which was finished as first parameter. This doesn't apply to afterAll where no parameter is passed Note that the after()\/afterAll() method will never be called if the animation is looping eternally. You can call after()\/afterAll() multiple times to add more functions which should be executed."},{"uri":"animating\/references","text":"References target() returns SVG.Element The target method returns the element the animation is applied to: rect.fx.target() \/\/ returns rect situation returns object The current situation of an animation is stored in the situation object: rect.animate(3000).move(100, 100) rect.fx.situation \/\/-> everything is in here Available values are:  start (start time as a number in milliseconds) play (animation playing or not; true or false) pause (time when the animation was last paused) duration (the chosen duration of the animation) ease (the chosen easing calculation) finish (start + duration) loop (the current loop; counting down if a number; true, false or a number) loops (if a number, the total number loops; true, false or a number) reverse (whether or not the animation should run backwards) reversing (true if the loop is currently reversing, otherwise false) "},{"uri":"events","text":"Events SVG.js supports named events, event listeners and custom events."},{"uri":"events\/basic","text":"Basic events returns itself Events can be bound to elements as follows: rect.click(function() {   this.fill({ color: '#f06' }) }) Removing it is quite as easy: rect.click(null) All available events are: click, dblclick, mousedown, mouseup, mouseover, mouseout, mousemove, touchstart, touchmove, touchleave, touchend and touchcancel."},{"uri":"events\/listeners","text":"Event listeners on() returns itself var click = function() {   this.fill({ color: '#f06' }) }  rect.on('click', click) Note: The context of this in the callback is bound to the element. You can change this context by applying your own object: rect.on('click', click, window) \/\/ context of this is window off() returns itself Unbinding events is just as easy: rect.off('click', click) Or to unbind all listeners for a given event: rect.off('click') Or even unbind all listeners for all events: rect.off() other elements But there is more to event listeners. You can bind events to html elements as well: SVG.on(window, 'click', click) Obviously unbinding is practically the same: SVG.off(window, 'click', click)"},{"uri":"events\/custom","text":"Custom events You can even use your own events. Just add an event listener for your event: rect.on('myevent', function() {   alert('ta-da!') }) Now you are ready to fire the event whenever you need: function whenSomethingHappens() {   rect.fire('myevent') }  \/\/ or if you want to pass an event function whenSomethingHappens(event) {   rect.fire(event) } You can also pass some data to the event: function whenSomethingHappens() {   rect.fire('myevent', {some:'data'}) }  rect.on('myevent', function(e) {   alert(e.detail.some) \/\/ outputs 'data' }) SVG.js supports namespaced events following the syntax event.namespace. A namespaced event behaves like a normal event with the difference that you can remove it without touching handlers from other namespaces. \/\/ attach rect.on('myevent.namespace', function(e) {   \/\/ do something })  \/\/ detach all handlers of namespace for myevent rect.off('myevent.namespace')  \/\/ detach all handlers of namespace rect.off('.namespace')  \/\/ detach all handlers including all namespaces rect.off('myevent) However you can't fire a specific namespaced event. Calling rect.fire('myevent.namespace') won't do anything while rect.fire('myevent') works and fires all attached handlers of the event Important: always make sure you namespace your event to avoid conflicts. Preferably use something very specific. So event.wicked for example would be better than something generic like event.svg."},{"uri":"classes","text":"Classes SVG.js adds a lot of functionality that is not related to the SVG spec. Most of the extras are part of the OO nature but there are other useful utilities as well."},{"uri":"classes\/arrays","text":"Arrays In SVG.js every value list string can be cast and passed as an array. This makes writing them more convenient but also adds a lot of key functionality to them."},{"uri":"classes\/arrays\/array","text":"SVG.Array Is for simple, whitespace separated value strings: '0.343 0.669 0.119 0 0 0.249 -0.626 0.13 0 0 0.172 0.334 0.111 0 0 0 0 0 1 0' Can also be passed like this in a more manageable format: new SVG.Array([ .343,  .669, .119, 0,   0               , .249, -.626, .130, 0,   0               , .172,  .334, .111, 0,   0               , .000,  .000, .000, 1,  -0 ]) morph() returns itself In order to animate array values the morph() method lets you pass a destination value. This can be either the string value, a plain array or an instance of the same type of SVG.js array: var array = new SVG.PointArray([[0, 0], [100, 100]]) array.morph('100,0 0,100 200,200') This method will prepare the array ensuring both the source and destination arrays have the same length. In order to morph paths you need to include the svg.pathmorphing.js extension. at() returns new instance This method will morph the array to a given position between 0 and 1. Continuing with the previous example: array.at(0.27).toString() \/\/-> returns '27,0 73,100 127,127' Note that this method is currently not available on SVG.PathArray but will be soon. settle() returns itself When morphing is done the settle() method will eliminate any transitional points like duplicates: array.settle() Note that this method is currently not available on SVG.PathArray but will be soon. move() returns itself Moves geometry of the array with the given x and y values: var array = new SVG.PointArray([[0, 0], [100, 100]]) array.move(33,75) array.toString() \/\/-> returns '33,75 133,175' Note that this method is only available on SVG.PointArray and SVG.PathArray size() returns itself Resizes geometry of the array by the given width and height values: var array = new SVG.PointArray([[0, 0], [100, 100]]) array.move(100,100).size(222,333) array.toString() \/\/-> returns '100,100 322,433' Note that this method is only available on SVG.PointArray and SVG.PathArray reverse() returns itself Reverses the order of the array: var array = new SVG.PointArray([[0, 0], [100, 100]]) array.reverse() array.toString() \/\/-> returns '100,100 0,0' bbox() returns object Gets the bounding box of the geometry of the array: array.bbox() Note that this method is only available on SVG.PointArray and SVG.PathArray"},{"uri":"classes\/arrays\/pointarray","text":"SVG.PointArray inherits from SVG.Array Is a bit more complex and is used for polyline and polygon elements. This is a poly-point string: '0,0 100,100' The dynamic representation: [   [0, 0] , [100, 100] ] Precompiling it as an SVG.PointArray: new SVG.PointArray([   [0, 0] , [100, 100] ]) Note that every instance of SVG.Polyline and SVG.Polygon carries a reference to the SVG.PointArray instance: polygon.array() \/\/-> returns the SVG.PointArray instance"},{"uri":"classes\/arrays\/patharray","text":"SVG.PathArray inherits from SVG.Array Path arrays carry arrays representing every segment in a path string: 'M0 0L100 100z' The dynamic representation: [   ['M', 0, 0] , ['L', 100, 100] , ['z'] ] Precompiling it as an SVG.PathArray: new SVG.PathArray([   ['M', 0, 0] , ['L', 100, 100] , ['z'] ]) Note that every instance of SVG.Path carries a reference to the SVG.PathArray instance: path.array() \/\/-> returns the SVG.PathArray instance Syntax The syntax for patharrays is very predictable. They are basically literal representations in the form of two dimentional arrays. Move To Original syntax is M0 0 or m0 0. The SVG.js syntax ['M',0,0] or ['m',0,0]. Line To Original syntax is L100 100 or l100 100. The SVG.js syntax ['L',100,100] or ['l',100,100]. Horizontal line Original syntax is H200 or h200. The SVG.js syntax ['H',200] or ['h',200]. Vertical line Original syntax is V300 or v300. The SVG.js syntax ['V',300] or ['v',300]. Bezier curve Original syntax is C20 20 40 20 50 10 or c20 20 40 20 50 10. The SVG.js syntax ['C',20,20,40,20,50,10] or ['c',20,20,40,20,50,10]. Or mirrored with S: Original syntax is S40 20 50 10 or s40 20 50 10. The SVG.js syntax ['S',40,20,50,10] or ['s',40,20,50,10]. Or quadratic with Q: Original syntax is Q20 20 50 10 or q20 20 50 10. The SVG.js syntax ['Q',20,20,50,10] or ['q',20,20,50,10]. Or a complete shortcut with T: Original syntax is T50 10 or t50 10. The SVG.js syntax ['T',50,10] or ['t',50,10]. Arc Original syntax is A 30 50 0 0 1 162 163 or a 30 50 0 0 1 162 163. The SVG.js syntax ['A',30,50,0,0,1,162,163] or ['a',30,50,0,0,1,162,163]. Close Original syntax is Z or z. The SVG.js syntax ['Z'] or ['z']. The best documentation on paths can be found at MDN."},{"uri":"classes\/color","text":"Color SVG.js has a dedicated color class handling different types of colors. Accepted values are:  hex string; three based (e.g. #f06) or six based (e.g. #ff0066) new SVG.Color('#f06') rgb string; e.g. rgb(255, 0, 102) new SVG.Color('rgb(255, 0, 102)') rgb object; e.g. { r: 255, g: 0, b: 102 } new SVG.Color({ r: 255, g: 0, b: 102 })  Note that when working with objects is important to provide all three values every time. The SVG.Color instance has a few methods of its own. toHex() returns hex color string Get hex value: color.toHex() \/\/-> returns '#ff0066' toRgb() returns rgb color string Get rgb string value: color.toRgb() \/\/-> returns 'rgb(255,0,102)' brightness() returns number Get the brightness of a color: color.brightness() \/\/-> returns 0.344 This is the perceived brighness where 0 is black and 1 is white. morph() returns itself Make a color morphable: color.morph('#000') at() returns SVG.Color Get morphable color at given position: var color = new SVG.Color('#ff0066').morph('#000') color.at(0.5).toHex() \/\/-> '#7f0033'"},{"uri":"classes\/data","text":"Data The data() method allows you to bind arbitrary objects, strings and numbers to SVG elements. data() as getter returns value Fetching the values is similar to the attr() method: var key = rect.data('key') data() as setter returns itself rect.data('key', { value: { data: 0.3 }}) Or set multiple values at once: rect.data({   forbidden: 'fruit' , multiple: {     values: 'in'   , an: 'object'   } }) Removing the data altogether: rect.data('key', null) Your values will always be stored as JSON and in some cases this might not be desirable. If you want to store the value as-is, just pass true as the third argument: rect.data('key', 'value', true)"},{"uri":"classes\/memory","text":"Memory remember() as getter returns value To retrieve a memory rect.remember('oldBBox') remember() as setter returns itself Storing data in-memory is very much like setting attributes: rect.remember('oldBBox', rect.bbox()) Multiple values can also be remembered at once: rect.remember({   oldFill:    rect.attr('fill') , oldStroke:  rect.attr('stroke') }) forget() returns itself Erasing a single memory: rect.forget('oldBBox') Or erasing multiple memories at once: rect.forget('oldFill', 'oldStroke') And finally, just erasing the whole memory: rect.forget()"},{"uri":"classes\/matrix","text":"Matrix Matrices in SVG.js have their own class SVG.Matrix, wrapping the native SVGMatrix. They add a lot of functionality like extracting transform values, matrix morphing and improvements on the native methods. SVG.Matrix In SVG.js matrices accept various values on initialization. Without a value: var matrix = new SVG.Matrix matrix.toString() \/\/-> returns matrix(1,0,0,1,0,0) Six arguments: var matrix = new SVG.Matrix(1, 0, 0, 1, 100, 150) matrix.toString() \/\/-> returns matrix(1,0,0,1,100,150) A string value: var matrix = new SVG.Matrix('1,0,0,1,100,150') matrix.toString() \/\/-> returns matrix(1,0,0,1,100,150) An object value: var matrix = new SVG.Matrix({ a: 1, b: 0, c: 0, d: 1, e: 100, f: 150 }) matrix.toString() \/\/-> returns matrix(1,0,0,1,100,150) A native SVGMatrix: var svgMatrix = svgElement.getCTM() var matrix = new SVG.Matrix(svgMatrix) matrix.toString() \/\/-> returns matrix(1,0,0,1,0,0) Even an instance of SVG.Element: var rect = draw.rect(50, 25) var matrix = new SVG.Matrix(rect) matrix.toString() \/\/-> returns matrix(1,0,0,1,0,0) extract() returns object Gets the calculated values of the matrix as an object: matrix.extract() The returned object contains the following values:  x (translation on the x-axis) y (translation on the y-axis) skewX (calculated skew on x-axis) skewY (calculated skew on y-axis) scaleX (calculated scale on x-axis) scaleY (calculated scale on y-axis) rotation (calculated rotation)  clone() returns SVG.Matrix Returns an exact copy of the matrix: matrix.clone() morph() returns itself In order to animate matrices the morph() method lets you pass a destination matrix. This can be any value a SVG.Matrix would accept on initialization: matrix.morph('matrix(2,0,0,2,100,150)') at() returns SVG.Matrix This method will morph the matrix to a given position between 0 and 1: matrix.at(0.27) This will only work when a destination matirx is defined using the morph() method. multiply() returns SVG.Matrix Multiplies by another given matrix: matrix.matrix(matrix2) inverse() returns SVG.Matrix Creates an inverted matix: matrix.inverse() translate() returns SVG.Matrix Translates matrix by a given x and y value: matrix.translate(10, 20) scale() returns SVG.Matrix Scales matrix uniformal with one value: \/\/ scale matrix.scale(2) Scales matrix non-uniformal with two values: \/\/ scaleX, scaleY matrix.scale(2, 3) Scales matrix uniformal on a given center point with three values: \/\/ scale, cx, cy matrix.scale(2, 100, 150) Scales matrix non-uniformal on a given center point with four values: \/\/ scaleX, scaleY, cx, cy matrix.scale(2, 3, 100, 150) rotate() returns SVG.Matrix Rotates matrix by degrees with one value given: \/\/ degrees matrix.rotate(45) Rotates a matrix by degrees around a given point with three values: \/\/ degrees, cx, cy matrix.rotate(45, 100, 150) flip() returns SVG.Matrix Flips matrix over a given axis: matrix.flip('x') or matrix.flip('y') By default elements are flipped over their center point. The flip axis position can be defined with the second argument: matrix.flip('x', 150) or matrix.flip('y', 100) skew() returns SVG.Matrix Skews matrix a given degrees over x and or y axis with two values: \/\/ degreesX, degreesY matrix.skew(0, 45) Skews matrix a given degrees over x and or y axis on a given point with four values: \/\/ degreesX, degreesY, cx, cy matrix.skew(0, 45, 150, 100) around() returns SVG.Matrix Performs a given matrix transformation around a given center point: \/\/ cx, cy, matrix matrix.around(100, 150, new SVG.Matrix().skew(0, 45)) The matrix passed as the third argument will be used to multiply. native() returns SVGMatrix Returns a native SVGMatrix extracted from the SVG.Matrix instance: matrix.native() toString() returns string Converts the matrix to a transform string: matrix.toString() \/\/ -> matrix(1,0,0,1,0,0)"},{"uri":"classes\/number","text":"Number Numbers in SVG.js have a dedicated number class to be able to process string values. Creating a new number is simple: var number = new SVG.Number('78%') number.plus('3%').toString() \/\/-> returns '81%' number.valueOf() \/\/-> returns 0.81 Operators are defined as methods on the SVG.Number instance. plus() returns SVG.Number Addition: number.plus('3%') minus() returns SVG.Number Subtraction: number.minus('3%') times() returns SVG.Number Multiplication: number.times(2) divide() returns SVG.Number Division: number.divide('3%') to() returns SVG.Number Change number to another unit: number.to('px') morph() returns itself Make a number morphable: number.morph('11%') at() returns SVG.Number Get morphable number at given position: var number = new SVG.Number('79%').morph('3%') number.at(0.55).toString() \/\/-> '37.2%'"},{"uri":"classes\/set","text":"Set returns SVG.Set Sets are very useful if you want to modify or animate multiple elements at once. A set will accept all the same methods accessible on individual elements, even the ones that you add with your own plugins! Creating a set is exactly as you would expect: \/\/ create some elements var rect = draw.rect(100,100) var circle = draw.circle(100).move(100,100).fill('#f09')  \/\/ create a set and add the elements var set = draw.set() set.add(rect).add(circle)  \/\/ change the fill of all elements in the set at once set.fill('#ff0') A single element can be a member of many sets. Sets also don't have a structural representation, in fact they are just fancy array's. add() returns itself Add an element to a set: set.add(rect) Quite a useful feature of sets is the ability to accept multiple elements at once: set.add(rect, circle) each() returns itself Iterating over all members in a set is the same as with svg containers: set.each(function(i) {   this.attr('id', 'shiny_new_id_' + i) }) Note that this refers to the current child element. has() returns boolean Determine if an element is member of the set: set.has(rect) index() returns number Returns the index of a given element in the set. set.index(rect) \/\/-> -1 if element is not a member get() returns SVG.Element Gets the element at a given index: set.get(1) first() returns SVG.Element Gets the first element: set.first() last() returns SVG.Element Gets the last element: set.last() bbox() returns SVG.BBox Get the bounding box of all elements in the set: set.bbox() remove() returns itself To remove an element from a set: set.remove(rect) clear() returns itself Or to remove all elements from a set: set.clear() animate() returns SVG.SetFX Sets work with animations as well: set.animate(3000).fill('#ff0')"},{"uri":"importing-exporting","text":"Import \/ export SVG svg() as getter returns string Exporting the full generated SVG, or a part of it, can be done with the svg() method: draw.svg() Exporting works on individual elements as well: var rect = draw.rect() var svg  = rect.svg() svg() as setter returns itself Importing is done with the same method by passing a string of svg as the first argument: draw.svg('') Importing works on any element that inherits from SVG.Parent, which is basically every element that can contain other elements."},{"uri":"extending","text":"Extending Due to the Object Oriented nature of SVG.js, objects\/prototypes can be extended on any level. The invent() method provides a convenient way to implement your own functionality."},{"uri":"extending\/svg-invent","text":"SVG.invent() Creating your own custom elements with SVG.js is a piece of cake thanks to the SVG.invent function. For the sake of this example, lets \"invent\" a shape. We want a rect with rounded corners that are always proportional to the height of the element. The new shape lives in the SVG namespace and is called Rounded. Here is how we achieve that. SVG.Rounded = SVG.invent({   \/\/ Define the type of element that should be created   create: 'rect'    \/\/ Specify from which existing class this shape inherits , inherit: SVG.Shape    \/\/ Add custom methods to invented shape , extend: {     \/\/ Create method to proportionally scale the rounded corners     size: function(width, height) {       return this.attr({         width:  width       , height: height       , rx:     height \/ 5       , ry:     height \/ 5       })     }   }    \/\/ Add method to parent elements , construct: {     \/\/ Create a rounded element     rounded: function(width, height) {       return this.put(new SVG.Rounded).size(width, height)     }    } }) To create the element in your drawing: var rounded = draw.rounded(200, 100) That's it, the invention is now ready to be used! Accepted values The SVG.invent() function always expects an object. The object can have the following configuration values:  create: can be either a string with the node name (e.g. rect, ellipse, ...) or a custom initializer function; [required] inherit: the desired SVG.js class to inherit from (e.g. SVG.Shape, SVG.Element, SVG.Container, SVG.Rect, ...); [optional but recommended] extend: an object with the methods that should be applied to the element's prototype; [optional] construct: an object with the methods to create the element on the parent element; [optional] parent: an SVG.js parent class on which the methods in the passed construct object should be available - defaults to SVG.Container; [optional]  Usage notes It should be emphasized that in the configuration object passed to SVG.invent():  construct does not supply constructors, but rather methods that are likely to call constructors; create specifies the constructor for the type you are defining, and is not analogous to Object.create().  When defining specialized svg elements (such as SVG.Rounded in the example above), the function specified by create needs to do all the work of adding the element to the DOM for the svg document and connecting the DOM node to the SVG.js interface. All this is done automatically when the value of create is a string identifying an element type. If needed, see the source for a sense of how to do it explicitly. Though the defaults are geared toward creating svg elements for the SVG.js framework, SVG.invent() can be used as a generalized function for defining types in Javascript. When used in this more general way, the function supplied as a value for create should be written as an ordinary JS constructor. (Indeed, the function is simply returned as the constructor for your newly defined type.) Svg.js uses the SVG.invent() function to create all internal elements. A look at the source will show how this function is used in various ways."},{"uri":"extending\/svg-extend","text":"SVG.extend() SVG.js has a modular structure. It is very easy to add your own methods at different levels. Let's say we want to add a method to all shape types then we would add our method to SVG.Shape: SVG.extend(SVG.Shape, {   paintRed: function() {     return this.fill('red')   } }) Now all shapes will have the paintRed method available. Say we want to have the paintRed method on an ellipse apply a slightly different color: SVG.extend(SVG.Ellipse, {   paintRed: function() {     return this.fill('orangered')   } })  The complete inheritance stack for SVG.Ellipse is: SVG.Ellipse < SVG.Shape < SVG.Element The SVG document can be extended by using: SVG.extend(SVG.Doc, {   paintAllPink: function() {     this.each(function() {       this.fill('pink')     })   } }) You can also extend multiple elements at once: SVG.extend(SVG.Ellipse, SVG.Path, SVG.Polygon, {   paintRed: function() {     return this.fill('orangered')   } })"},{"uri":"plugins","text":"Plugins Here's a list of all plugins available for SVG.js. If you wrote one, please let us know!"},{"uri":"plugins\/svg-connectable-js","text":"svg.connectable.js svg.connectable.js to connect elements. svg.connectable.js fork to connect elements (added: curved connectors, you can use any self-made path as a connector, choosable 'center'\/'perifery' attachment, 'perifery' attachment for source \/ target SVG Paths uses smallest-distance algorithm between PathArray points)"},{"uri":"plugins\/svg-easing-js","text":"svg.easing.js svg.easing.js for more easing methods on animations."},{"uri":"plugins\/svg-draw-js","text":"svg.draw.js svg.draw.js to draw elements with your mouse."},{"uri":"plugins\/svg-draggable-js","text":"svg.draggable.js svg.draggable.js to make elements draggable."},{"uri":"plugins\/svg-filter-js","text":"svg.filter.js svg.filter.js adding svg filters to elements."},{"uri":"plugins\/svg-foreignobject-js","text":"svg.foreignobject.js svg.foreignobject.js foreignObject implementation (by john-memloom)."},{"uri":"plugins\/svg-intersections-js","text":"svg.intersections.js svg.intersections.js find intersections of paths and lines (by amatiash)"},{"uri":"plugins\/svg-math-js","text":"svg.math.js svg.math.js a math extension (by Nils Lagerkvist)."},{"uri":"plugins\/svg-path-js","text":"svg.path.js svg.path.js for manually drawing paths (by Nils Lagerkvist)."},{"uri":"plugins\/svg-pathmorphing-js","text":"svg.pathmorphing.js svg.pathmorphing.js to make path animatable"},{"uri":"plugins\/svg-resize-js","text":"svg.resize.js svg.resize.js to resize elements with your mouse."},{"uri":"plugins\/svg-screenbbox-js","text":"svg.screenbbox.js svg.screenbbox.js to get the bbox in screen coordinates from transformed path\/polygon\/polyline"},{"uri":"plugins\/svg-select-js","text":"svg.select.js svg.select.js to select elements."},{"uri":"plugins\/svg-shapes-js","text":"svg.shapes.js svg.shapes.js for more polygon based shapes."},{"uri":"plugins\/svg-textmorph-js","text":"svg.textmorph.js svg.textmorph.js to make text animatable."},{"uri":"plugins\/svg-topath-js","text":"svg.topath.js svg.topath.js to convert any other shape to a path."},{"uri":"plugins\/svg-topoly-js","text":"svg.topoly.js svg.topoly.js to convert a path to polygon or polyline."},{"uri":"contributing","text":"Contributing We love contributions. Yes indeed, we used the word LOVE! But please make sure you follow the same coding style. Here are some guidelines. Building After contributing you probably want to build the library to run some specs. Make sure you have Node.js installed on your system, cd to the svg.js directory and run: $ npm install Build SVG.js by running gulp: $ npm run build The resulting files are:  dist\/svg.js dist\/svg.min.js  Testing There is two ways to run the test suite. One is from the command line and the other is in your browser. To run the test suite at the command line, you need to have Firefox installed. $ npm test To run the test suite in your default browser, simply open \/spec\/SpecRunner.html. Usually by double click. If you are the cautious type, you might want to read, before you push , on how to prevent pushing failing commits. Before you push Imagine that you're tweaking some part of svg.js and as the responsible person you are, you made sure to run npm test before pushing. Unfortunately npm test tests the current dist\/svg.js which only has your edits if you first did npm run build. This has happen to me a couple of times and as a svg.js contributor, it's embarrassing. Fortunately git has a pre-push hook which can save yourself from the embarrassment. I have created a pre-commit hook that will build a new dist\/svg.js and run the tests. It's developed on Ubuntu 16.04 but should work on all *nix platforms. You can disable this check with: git push --no-verify pre-commit #!\/bin\/sh  npm run build:test && npm run test:quick  # check how the test went testCode=$? [ \"$testCode\" = 0 ] || echo \"Your current build does not pass our unit tests - please make them pass before you push\" # revert artifacts created during build git reset --hard $(git log -1 --pretty=%H) # exit with the test exit code exit $testCode A failed push looks something like this: git push  > svg.js@2.3.6 build:test \/home\/dotnet\/projects\/opensource\/svg.js > gulp unify  [14:20:12] Using gulpfile ~\/projects\/opensource\/svg.js\/gulpfile.js [14:20:12] Starting 'clean'... [14:20:12] Finished 'clean' after 34 ms [14:20:12] Starting 'unify'... [14:20:13] Full svg.js 137.14 kB [14:20:13] Finished 'unify' after 318 ms  > svg.js@2.3.6 test:quick \/home\/dotnet\/projects\/opensource\/svg.js > karma start .config\/karma.quick.js  PhantomJS 2.1.1 (Linux 0.0.0) ERROR   TypeError: undefined is not a function (evaluating 'root.callFailingFooBar()')   at dist\/svg.js:21  npm ERR! Linux 4.4.0-45-generic npm ERR! argv \"\/home\/dotnet\/.nvm\/versions\/node\/v7.0.0\/bin\/node\" \"\/home\/dotnet\/.nvm\/versions\/node\/v7.0.0\/bin\/npm\" \"run\" \"test:quick\" npm ERR! node v7.0.0 npm ERR! npm  v3.10.8 npm ERR! code ELIFECYCLE npm ERR! svg.js@2.3.6 test:quick: `karma start .config\/karma.quick.js` npm ERR! Exit status 1 npm ERR!  npm ERR! Failed at the svg.js@2.3.6 test:quick script 'karma start .config\/karma.quick.js'. npm ERR! Make sure you have the latest version of node.js and npm installed. npm ERR! If you do, this is most likely a problem with the svg.js package, npm ERR! not with npm itself. npm ERR! Tell the author that this fails on your system: npm ERR!     karma start .config\/karma.quick.js npm ERR! You can get information on how to open an issue for this project with: npm ERR!     npm bugs svg.js npm ERR! Or if that isn't available, you can get their info via: npm ERR!     npm owner ls svg.js npm ERR! There is likely additional logging output above.  npm ERR! Please include the following file with any support request: npm ERR!     \/home\/dotnet\/projects\/opensource\/svg.js\/npm-debug.log Your current build does not pass our unit tests - please make them pass before you push HEAD is now at b66f005 Calling new awesome method error: failed to push some refs to 'https:\/\/github.com\/dotnetCarpenter\/svg.js.git' Install Put pre-commit in your local svg.js repository, in the .git\/hooks folder and make it executable: sudo chmod +x .git\/hooks\/pre-push To disable the check when you push, write: git push --no-verify"},{"uri":"contributing\/coding-style","text":"Coding Style Indentation We do it with two spaces. Make sure you don't start using tabs because then things get messy. Avoid hairy code We like to keep things simple and clean, don't write anything you don't need. So use single quotes where possible and avoid semicolons, we're not writing PHP here. Good: var text = draw.text('with single quotes here')   , nest = draw.nested().attr('x', '50%')  for (var i = 0; i < 5; i++)   if (i != 3)     nest.circle(i * 100) Bad: var text = draw.text(\"with double quotes here\"); var nest = draw.nested().attr(\"x\", \"50%\");  for (var i = 0; i < 5; i++) {   if (i != 3) {     nest.circle(100);   }; }; Minimize variable declarations All local variables should be declared at the beginning of a function or method unless there is ony one variable to declare. Although it is not required to assign them at the same moment. When if statements are involved, requiring some variables only to be present in the statement, the necessary variables should be declared right after the if statement. Good: function reading_board() {   var aap, noot, mies    aap  = 1   noot = 2   mies = aap + noot } Bad: function reading_board() {   var aap  = 1   var noot = 2   var mies = aap + noot } Let your code breathe people! Don't try to be a code compressor yourself, they do way a better job anyway. Give your code some spaces and newlines. Good: var nest = draw.nested().attr({   x:      10 , y:      20 , width:  200 , height: 300 })  for (var i = 0; i < 5; i++)   nest.circle(100) Bad: var nest=draw.nested().attr({x:10,y:20,width:200,height:300}); for(var i=0;i"},{"uri":"contributing\/documentation","text":"Documentation The SVG.js docs are built upon Kirby with the KDoc theme. Requirements You'll need:  PHP 5.4+ Node.js  Getting started   Download or clone the svgdotjs.github.io repo and switch to the source branch.   Run npm install. This is only required the first time.  Run npm run dev which will open up your default browser with the docs running.  Writing Log in to Kirby on localhost:8008\/panel using username svgjs and password svgjs. The text editors in Kirby are Markdown and Kirbytext enabled. Building the static version   Go to localhost:8008\/statify.php in a web browser to run the build. The static files will be generated at static at the root of the repo.   Move the static folder out of the repo (e.g. your Desktop).   Commit and push the changes in the source branch and switch to the master branch.   Replace everything in the master branch with the contents of the static folder.  Commit and push the changes in the master branch and you're done! "},{"uri":"compatibility","text":"Compatibility Desktop  Firefox 3+ Chrome 4+ Safari 3.2+ Opera 9+ IE9+  Mobile  iOS Safari 3.2+ Android Browser 3+ Opera Mobile 10+ Chrome for Android 18+ Firefox for Android 15+ "},{"uri":"acknowledgements-thanks","text":"Acknowledgements & Thanks Documentation running on Kirby using Nate Steiner's KDoc theme. Special thanks to Ulrich-Matthias Sch\u00e4fer and Jon Ronnenberg for their many hours spent on maintaining SVG.js. Also thanks to Alex Ewerl\u00f6f for the logo and other contributions. And of course thanks to all the many developers who contributed to SVG.js over the years. SVG.js and its documentation is released under the terms of the MIT License."},{"uri":"error","text":"The page has not been found."},{"uri":"sitemap","text":""}]